BlockRegistry.createBlock("manualKineticGenerator", [
	{name: "Manual Kinetic Generator", texture: [["machine_bottom", 0], ["ind_furnace_side", 0], ["heat_generator_side", 0], ["heat_pipe", 0], ["ind_furnace_side", 0], ["ind_furnace_side", 0]], inCreative: true},
], "machine");
BlockRegistry.setBlockMaterial(BlockID.manualKineticGenerator, "stone", 1);
ItemName.addTierTooltip(BlockID.manualKineticGenerator, 4);

TileRenderer.setStandardModelWithRotation(BlockID.manualKineticGenerator, 0, [["machine_bottom", 0], ["ind_furnace_side", 0], ["heat_generator_side", 0], ["heat_pipe", 0], ["ind_furnace_side", 0], ["ind_furnace_side", 0]], true);
TileRenderer.registerModelWithRotation(BlockID.manualKineticGenerator, 0, [["machine_bottom", 0], ["ind_furnace_side", 1], ["heat_generator_side", 1], ["heat_pipe", 1], ["ind_furnace_side", 1], ["ind_furnace_side", 1]], true);
TileRenderer.setRotationFunction(BlockID.manualKineticGenerator, true);

Callback.addCallback("PreLoaded", function() {
	/*Recipes.addShaped({id: BlockID.manualKineticGenerator, count: 1, data: 0}, [
		"sm",
	], ['s', ItemID.machineCasing, 0, 'm', levelId!!!, -1]);*/
});

namespace Machine {
    export class ManualKineticGenerator extends ElectricMachine {
		getTier(): number {
			return 1;
		}

		/*setupContainer(): void {
			this.container.setGlobalAddTransferPolicy((container, name, id, amount, data) => {
				if (name == "slotEnergy") {
					return ChargeItemRegistry.isValidStorage(id, "Eu", this.getTier())? amount : 0;
				}
				if (id == ItemID.electricMotor && container.getSlot(name).count == 0) {
					return 1;
				}
				return 0;
			});
		}*/

		onClick(): void {
			let maxOutput = 400;
			let output = 0;

			let side = this.getFacing();
			let coords = StorageInterface.getRelativeCoords(this, side);
			let tile = this.region.getTileEntity(coords) as IMomentOfMomentumConsumer;
			if (tile && tile.canReceiveAngularMomentum && tile.canReceiveAngularMomentum(side ^ 1)) {
			    output = tile.receiveReceiveAngularMomentum(Math.min(maxOutput, this.data.energy));
			 //if (output > 0) {
			    //this.setActive(true);
			    //this.data.energy -= output;
			    //let outputText = output.toString();
				
			//this.container.setText("textInfo1", outputText + "/");
		}
	/*if (output == 0) {
	    this.setActive(false);
	    this.container.setText("textInfo1", "0     /");
	}*/

	//this.dischargeSlot("slotEnergy");

	//this.container.setScale("energyScale", this.getRelativeEnergy());
	//this.container.setText("textInfo2", maxOutput);
	//this.container.sendChanges();
		}

		getEnergyStorage(): number {
			return 0;
		}

		canRotate(): boolean {
			return true;
		}
	}

	MachineRegistry.registerPrototype(BlockID.manualKineticGenerator, new ManualKineticGenerator());
}
